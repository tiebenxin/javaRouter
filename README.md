# javaRouter
Android 组件化开发项目demo，使用阿里ARouter

ARouter实现原理：在运行时先将添加了注解的类添加到生成类的参数的集合中——预添加，然后在初始化ARouter的时候(一般在application onCreate中)，通过获取指定包名路径下的class文件，
                将routeMeta信息加载到内存（本地集合）。 然后获取activity时，就是判断本地集合中有没有此activity信息。加载进内存有两种思路，一种是直接加载——加载进Warehouse.routes;另一种间接加载——先加载进
                Warehouse.groupIndex, 然后在获取通过获取Warehouse.groupIndex，中信息，重新加载进Warehouse.routes

ARouter实现思路：
1.生成两个类：一个是Root类，按项目结构中的模块名命名（如module_chat），实现IRootGroup接口，存储分组名及生成的group类名
            一个是Group类，按path命名的Group命名（如chat）,实现IRouteGroup接口，存储path及RouteMeta——activity数据封装类；

             public class ARouter$$Root$$module_chat implements IRouteRoot {
                @Override
                public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {
                   //（分组名,分组类名）
                   routes.put("chat", ARouter$$Group$$chat.class);
                }
             }

            public class ARouter$$Group$$chat implements IRouteGroup {
              @Override
              public void loadInto(Map<String, RouteMeta> atlas) {
                //（path,activity信息类）
                atlas.put("/chat/chat", RouteMeta.build(RouteType.ACTIVITY, ChatActivity.class, "/chat/chat", "chat", null, -1, -2147483648));
                atlas.put("/chat/detail", RouteMeta.build(RouteType.ACTIVITY, ChatDetailActivity.class, "/chat/detail", "chat", null, -1, -2147483648));
              }
            }


2.初始化：初始化有两个任务——初始化Context,而初始化本地集合

         /**
             * LogisticsCenter init, load all metas in memory. Demand initialization
             */
            public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {
                mContext = context;//初始化Context
                executor = tpe;

                try {
                    long startInit = System.currentTimeMillis();
                    //billy.qi modified at 2017-12-06
                    //load by plugin first
                    loadRouterMap();
                    if (registerByPlugin) {
                        logger.info(TAG, "Load router map by arouter-auto-register plugin.");
                    } else {
                        Set<String> routerMap;

                        // It will rebuild router map every times when debuggable.
                        if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {
                            logger.info(TAG, "Run with debug mode or new install, rebuild router map.");
                            // These class was generated by arouter-compiler.
                            routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);//加载所有生成的class
                            if (!routerMap.isEmpty()) {
                                context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();
                            }

                            PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.
                        } else {
                            logger.info(TAG, "Load router map from cache.");
                            routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));
                        }

                        logger.info(TAG, "Find router map finished, map size = " + routerMap.size() + ", cost " + (System.currentTimeMillis() - startInit) + " ms.");
                        startInit = System.currentTimeMillis();

                        for (String className : routerMap) {
                            if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {
                                // This one of root elements, load root.
                              //将group加载进内存Warehouse.groupsIndex，也可以
                                ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);
                            } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {
                                // Load interceptorMeta
                                ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);
                            } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {
                                // Load providerIndex
                                ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);
                            }
                        }
                    }

                    logger.info(TAG, "Load root element finished, cost " + (System.currentTimeMillis() - startInit) + " ms.");

                    if (Warehouse.groupsIndex.size() == 0) {
                        logger.error(TAG, "No mapping files were found, check your configuration please!");
                    }

                    if (ARouter.debuggable()) {
                        logger.debug(TAG, String.format(Locale.getDefault(), "LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));
                    }
                } catch (Exception e) {
                    throw new HandlerException(TAG + "ARouter init logistics center exception! [" + e.getMessage() + "]");
                }
            }

3.获取Activity.class,采用初始化Warehouse.groupIndex, 需要获取其中信息，再初始化Warehouse.routes

    public synchronized static void completion(Postcard postcard) {
        if (null == postcard) {
            throw new NoRouteFoundException(TAG + "No postcard!");
        }

        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());
        if (null == routeMeta) {    // Maybe its does't exist, or didn't load.
            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.
            if (null == groupMeta) {
                throw new NoRouteFoundException(TAG + "There is no route match the path [" + postcard.getPath() + "], in group [" + postcard.getGroup() + "]");
            } else {
                // Load route and cache it into memory, then delete from metas.
                try {
                    if (ARouter.debuggable()) {
                        logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] starts loading, trigger by [%s]", postcard.getGroup(), postcard.getPath()));
                    }
                    //获取IRouteGroup，初始化Warehouse.routes
                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();
                    logger.debug(TAG, String.format(Locale.getDefault(), "init loadInfo-- group=[%s]  path=[%s]", postcard.getGroup(), postcard.getPath()));
                    iGroupInstance.loadInto(Warehouse.routes);
                    Warehouse.groupsIndex.remove(postcard.getGroup());

                    if (ARouter.debuggable()) {
                        logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] has already been loaded, trigger by [%s]", postcard.getGroup(), postcard.getPath()));
                    }
                } catch (Exception e) {
                    throw new HandlerException(TAG + "Fatal exception when loading group meta. [" + e.getMessage() + "]");
                }

                completion(postcard);   // Reload
            }
        } else {
            postcard.setDestination(routeMeta.getDestination());
            postcard.setType(routeMeta.getType());
            postcard.setPriority(routeMeta.getPriority());
            postcard.setExtra(routeMeta.getExtra());

            Uri rawUri = postcard.getUri();
            if (null != rawUri) {   // Try to set params into bundle.
                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);
                Map<String, Integer> paramsType = routeMeta.getParamsType();

                if (MapUtils.isNotEmpty(paramsType)) {
                    // Set value by its type, just for params which annotation by @Param
                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {
                        setValue(postcard,
                                params.getValue(),
                                params.getKey(),
                                resultMap.get(params.getKey()));
                    }

                    // Save params name which need auto inject.
                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));
                }

                // Save raw uri
                postcard.withString(ARouter.RAW_URI, rawUri.toString());
            }

            switch (routeMeta.getType()) {
                case PROVIDER:  // if the route is provider, should find its instance
                    // Its provider, so it must implement IProvider
                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();
                    IProvider instance = Warehouse.providers.get(providerMeta);
                    if (null == instance) { // There's no instance of this provider
                        IProvider provider;
                        try {
                            provider = providerMeta.getConstructor().newInstance();
                            provider.init(mContext);
                            Warehouse.providers.put(providerMeta, provider);
                            instance = provider;
                        } catch (Exception e) {
                            throw new HandlerException("Init provider failed! " + e.getMessage());
                        }
                    }
                    postcard.setProvider(instance);
                    postcard.greenChannel();    // Provider should skip all of interceptors
                    break;
                case FRAGMENT:
                    postcard.greenChannel();    // Fragment needn't interceptors
                default:
                    break;
            }
        }
    }




